
## AtomicLong vs LongAdder

+ При равномерной read/write нагрузке, а так же при преобладающем чтении Atomic выигрывает.
+ При преобладании write нагрузки LongAdder намного эффективнее.


---

## ReentrantLock vs ReadWriteLock vs StampedLock vs Semaphore(1)

Semaphore имеет примерно такие же тенденции как и ReentrantLock, но отстает от него в производительности.

+ При равномерной read/write нагрузке лидирует с большим отрывом StampedLock tryOptimistic реализация. Следом идет ReentrantLock
+ При преобладающем чтении так же лидирует с огромным отрывом оптимистичная реализация.
+ При *write* нагрузке ReentrantLock выдал лучший результат, такой же результат был получен и с помощью ReadWriteLock. Оптимистичная реализация при такой нагрузке отстает.

*fair* флаг - сильно уменьшает производительность в любой реализации Lock

---
## ReentrantLock vs Synchronized

При блокировке и на запись и на чтение результат примерно одинаковый, ReentrantLock более производителен.

+ Максимально быстрым вариантом будет volatile переменная для чтения и блокировка на запись при равномерной нагрузке.
+ При преобладающем чтении лучше всего использовать volatile переменную без синхронизации на чтение, а на запись использовать либо оптимистическую синхронизацию
+ При преобладающей записи syncronized и lock будут давать примерно один и тот же результат
